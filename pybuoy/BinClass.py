import numpy as np
import matplotlib.pyplot as plt

class BinPlots:

    
    def plot_prof(self,ax,bin_):
        """
        This function plots the average current 
        velocity profile in bin_ on ax. Bin is 
        assumed to be of the form:
        -bin_ = [[time0,depth0...timeNdepth0]
        -         :                        :  
        -        [time0,depthN...timeN,depthN]]
        INPUTS:
            -ax = matplotlib axis to plot profile on.
            -bin_ = vertical velocity provile array.
        PLOTS:
            -Time or horizontally averaged velocity profile."""
        
        ax.plot(np.nanmean(bin_,axis=1))
        
    def plot_prof_bins1D(self,bins):
        """
        This function plots a row of current 
        velocity profile bins to a row of 
        plt.axes.
        INPUTS:
            -plot axs.
            -bins = Bin().binthat2d() results.
        PLOTS:
            -The component row on a row of subplots."""
        
        Ncols = len(bins)
        
        fig,axs = plt.subplots(1,Ncols)
        print(axs.shape)
        for col in range(Ncols):
            #         for row in range(Nrows):
            axs[col].plot(np.nanmean(bins[col],axis=1))

        return fig,axs


class Bins(BinPlots):

    def __init__(self):
        pass

    def binit(self,data=[],bins=[],rhs=True):
        """
        Returns a 1 x N bins array of binned data.
        Use when the input data needs to be binned
        by its own values.."""
            
        # Create array of bin indicies
        bin_index = np.digitize(data,bins,right=rhs)

        out = []
        i=0
        while i <= len(bins): 
            out.append([])
            i+=1
        i=0
        while i < len(data):
            if data[i] != bins[0]:
                out[int(bin_index[i])].append(data[i])
            else:
                out[1].append(data[i])
            i+=1
        return np.array(out[1:-1],dtype=object)

    def length_check(self,a,b):
            """
            returns the shortest array between a and b along axis 0
            """
            testlist = [a,b]
            lengths = list(map(len,testlist))

            if lengths[0]==lengths[1]:
                return a

            elif lengths[0] < lengths[1]:
                return a
            else:
                return b

    def binthat(self,control=[],target=[],bins=[],rhs=True,angles=False):
        """
        Returns an nd array of binned target
        data.  Bins are generated by the control
        data.  Bin indicies from the control data
        are used to map the target data to bins.
        
        These two lines can be used to do the work of the while loop
        if a hard edge on the outside edges of the first and last bin
        is not needed. They are faster but not by too much
        
        sort = lambda target,index : out[int(index)].append(target)
        x = list(map(sort,target,bin_index))
        
        ASSUMES:
        1. Control and target data are syncronous
        along the independent variable"""

        bin_index = np.digitize(control,bins,right=rhs)

        shortest = self.length_check(control,target)
        
        out = np.zeros(len(bins)+1,dtype=object)
        i=0
        while i <= len(bins): 
            out[i] = []
            i+=1
        
        i=0
        while i < len(shortest):
            if control[i] != bins[0]:
                out[int(bin_index[i])].append(target[i])
            else:
                out[1].append(target[i])
            i+=1

        for i in range(len(out)):

            out[i] = np.array(out[i])

            
        return out[1:-1]
                              
    def binthat2d(self,control,target,bins,rhs=True):
        """
        Returns an nd array of binned target
        data.  Bins are generated by the control
        data.  Bin indicies from the control data
        are used to map the target data to bins.
        
        These two lines can be used to do the work of the while loop
        if a hard edge on the outside edges of the first and last bin
        is not needed. They are faster but not by too much
        
        sort = lambda target,index : out[int(index)].append(target)
        x = list(map(sort,target,bin_index))
        
        ASSUMES:
        1. Control and target data are syncronous
        along the independent variable
        2. Control is a 1d array
        3. Target is a n x m array where n represents space and m represents time
        
        Control and target do not need to be the same length"""

        bin_index = np.digitize(control,bins,right=rhs)

        shortest = self.length_check(control,target[0])
        
        out = np.zeros(len(bins)+1,dtype=object)

        for i in range(len(out)):

            out[i] = np.array([np.full((len(target),100000),np.nan),0],dtype=object)
        i=0
        while i < len(shortest):
            
            if control[i] != bins[0]:
                
                
                Bin_index = int(out[int(bin_index[i])][1])
                
                addition = target[:,i]
                out[int(bin_index[i])][0][:,Bin_index] = addition
                
                out[int(bin_index[i])][1] += 1
            else:
            
                Bin_index = int(out[int(bin_index[i])][1])
                
                addition = target[:,i]
                out[1][0][:,Bin_index] = addition
                
                out[1][1] += 1
                
            i+=1
        # return out[1:-1]
        out = out[1:-1]
        for i in range(len(out)):
            out[i] = out[i][0][:,:out[i][1]]
        return out


    def monthlybins(data = [],yr = 2000):
        """
        This function does a thing then returns
        something else."""

        years = len(data)//(365*24)
        hr_per_yr = 8760
        out =[]
        months = [31,28,31,30,31,30,31,31,30,31,30,31]
        for i in range(12):
            out.append([])
            
        start = 0
        print('here we go...')
        for i in range(years):
            print('year:',yr)
            
            if yr%4 == 0:
                end = start + hr_per_yr+24
                year = data[start:end]
                
                months[1] = 29
                
                for i in range(0,12):
                    month_hrs = months[i]*24
                    hr0 = int(np.sum(months[0:i]))*24 # will return 0 for first month 
                    month = year[hr0:hr0+month_hrs]
                    out[i] = np.append(out[i],month)
                print('leap year')

                months[1] = 28
                
            else:
                end = start + hr_per_yr
                
                year = data[start:end]
                
                print(len(year),len(year)/365)
                
                for i in range(0,12):
                    month_hrs = months[i]*24
                    hr0 = int(np.sum(months[0:i]))*24 # will return 0 for first month 
                    month = year[hr0:hr0+month_hrs]
                    out[i] = np.append(out[i],month)
                print('normal year again')
    
            start = end
            yr +=1
        return out